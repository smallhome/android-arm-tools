#!/bin/sh
setup()
{
    return 0
}

usage() 
{
    cat <<-EOF >&2
    usage: ./${0##*/} [ -d TMPDIR ]
    [ -f CMDFILES(,...) ] [ -l LOGFILE ]
    [ -o OUTPUTFILE ] -p -q [ -r TOPDIR/results ] [ -s PATTERN ] [ -t DURATION ]
    -v [ -w CMDFILEADDR ]

    -d TMPDIR		Directory where temporary files will be created.
    -f CMDFILES		Execute user defined list of testcases (separate with ',')
    -h 			Help. Prints all available options.
    -l LOGFILE		Log results of test in a logfile.
    -o OUTPUTFILE	Redirect test  to a file.
    -p              	Human readable format logfiles. 
    -q              	Print less verbose  to screen.
    -r TOPDIR		Fully qualified path where testsuite is installed.
    -s PATTERN		Only run test cases which match PATTERN.
    -t DURATION		Execute the testsuite for given duration. Examples:
                        -t 60s = 60 seconds
                        -t 45m = 45 minutes
                        -t 24h = 24 hours
                        -t 2d  = 2 days
    -v			Print more verbose  to screen.
    -w CMDFILEADDR	Uses wget to get the user's list of testcases.

    example: ./${0##*/} -p -q  -l /tmp/result-log.$$ -o /tmp/result-.$$ -C /tmp/result-failed.$$ -d ${PWD}

	EOF
exit 0
}

main()
{
    local CMDFILES=""
    local PRETTY_PRT=""
    local ALT_DIR_RES=0
    local QUIET_MODE=""
    local VERBOSE_MODE=""
    local DURATION=""
    local CMDFILEADDR=""
    local LOGFILE_NAME=""
    local LOGFILE=""
    local OUTPUTFILE_NAME=""
    local OUTPUTFILE=""
    local TAG_RESTRICT_STRING=""
    local DEFAULT_FILE_NAME_GENERATION_TIME=`date +"%Y_%b_%d-%Hh_%Mm_%Ss"`

    while getopts d:f:hl:o:pqr:s:t:vw: arg
    do  case $arg in
        d)  # append $$ to TMP, as it is recursively 
            # removed at end of script.
            export TMP="$OPTARG"
            export TMPDIR="$TMP";;
        f)  # Execute user defined set of testcases.
            # Can be more then one file, just separate it with ',', like:
            # -f nfs,commands,/tmp/testfile
            CMDFILES=$OPTARG;;
        h)  usage;;

        l)
            LOGFILE_NAME="$OPTARG"
            case $OPTARG in
            /*)
                LOGFILE="-l $OPTARG" ;;
            *)    
                LOGFILE="-l $TOPDIR/results/$OPTARG"
            esac ;;

        o)  OUTPUTFILE_NAME="$OPTARG"
            case $OPTARG in
            /*)
                OUTPUTFILE="-o $OPTARG";;
            *)
                OUTPUTFILE="-o $TOPDIR/$OPTARG"
            esac ;;
        p)  PRETTY_PRT=" -p ";;

        q)  QUIET_MODE=" -q ";;

        r)  TOPDIR=$OPTARG;;

        s)  TAG_RESTRICT_STRING=$OPTARG;;

        t)  # In case you want to specify the time 
            # to run from the command line 
            # (2m = two minutes, 2h = two hours, etc)
            DURATION="-t $OPTARG" ;;

        v)  VERBOSE_MODE=1;;

        w)  CMDFILEADDR=$OPTARG;;

        \?) usage;;
        esac
    done

    ## It would be nice to create a default log file even if the user has not mentioned
    if [ ! "$LOGFILE" ]; then                                ## User has not mentioned about Log File name
       LOGFILE_NAME=$DEFAULT_FILE_NAME_GENERATION_TIME
       LOGFILE="-l $TOPDIR/results/STRESS_RUN_ON-$LOGFILE_NAME.log"
       PRETTY_PRT=" -p "
    fi

    # If user does not provide a command file select a default set of testcases
    # to execute.

    [ -n "$CMDFILES" ] && \
    {
        for SCENFILES in `echo "$CMDFILES" | sed 's/,/\n/g'`
        do
            [ -f "$SCENFILES" ] || SCENFILES="$TOPDIR/runtest/$SCENFILES"
            cat "$SCENFILES" >> ${TMP}/alltests || \
            {
                echo "FATAL: unable to create command file"
                exit 1
            }
        done
    }

    [ -n "$CMDFILEADDR" ] && \
    {
        wget -q "${CMDFILEADDR}" -O ${TMP}/wgetcmdfile
        if [ $? -ne 0 ]; then
            echo "FATAL: error while getting the command file with wget (address $CMDFILEADDR)"
            exit 1
        fi
        cat "${TMP}/wgetcmdfile" >> ${TMP}/alltests || \
        {
            echo "FATAL: unable to create command file"
            exit 1
        }
    }

    # If enabled, execute only test cases that match the PATTERN
    if [ -n "$TAG_RESTRICT_STRING" ]
    then
        mv -f ${TMP}/alltests ${TMP}/alltests.orig
        grep $TAG_RESTRICT_STRING ${TMP}/alltests.orig > ${TMP}/alltests #Not worth checking return codes for this case
    fi

    [ ! -z "$QUIET_MODE" ] && { echo "INFO: Test start time: $(date)" ; }
    PAN_COMMAND="${INSTALLDIR}/bin/pan $QUIET_MODE -e -S $DURATION -a $$ \
    -n $$ $PRETTY_PRT -f ${TMP}/alltests $LOGFILE $OUTPUTFILE"
    if [ ! -z "$VERBOSE_MODE" ] ; then
      echo "COMMAND:    $PAN_COMMAND"
      if [ ! -z "$TAG_RESTRICT_STRING" ] ; then
        echo "INFO: Restricted to $TAG_RESTRICT_STRING"
      fi
    fi
    #$PAN_COMMAND #Duplicated code here, because otherwise if we fail, only "PAN_COMMAND" gets 

    ## Display the Output/Log/Failed/ file names here
    echo -e "LOG File: \c"
    echo $LOGFILE | cut -b4-

    if [ "$OUTPUTFILE" ]; then
       echo -e "OUTPUT File: \c"
       echo $OUTPUTFILE | cut -b4-
    fi

    echo "Running tests......."
    test_start_time=$(date)
    ${INSTALLDIR}/bin/pan $QUIET_MODE -e -S $DURATION -a $$ -n $$ $PRETTY_PRT -f ${TMP}/alltests $LOGFILE $OUTPUTFILE

    if [ $? -eq 0 ]; then
      echo "INFO: pan reported all tests PASS"
      VALUE=0
      export STRESS_EXIT_VALUE=0;
    else
      echo "INFO: pan reported some tests FAIL"
      VALUE=1
      export STRESS_EXIT_VALUE=1;
    fi

    [ ! -z "$QUIET_MODE" ] && { echo "INFO: Test end time: $(date)" ; }

    cat <<-EOF >&1

       ###############################################################"
                          "Done executing testcases."
       ###############################################################"

	EOF
    exit $VALUE
}

cleanup()
{
    rm -rf ${TMP}
}

trap "cleanup" 0
setup
main "$@"
